/*
 * Copyright 2018 Systems Research Group, University of St Andrews:
 * <https://github.com/stacs-srg>
 *
 * This file is part of the module core.
 *
 * core is free software: you can redistribute it and/or modify it under the terms of the GNU General Public
 * License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * core is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with core. If not, see
 * <http://www.gnu.org/licenses/>.
 */
package uk.ac.standrews.cs.sos.impl.manifest;

import uk.ac.standrews.cs.guid.IGUID;
import uk.ac.standrews.cs.guid.impl.keys.InvalidID;
import uk.ac.standrews.cs.sos.exceptions.crypto.SignatureException;
import uk.ac.standrews.cs.sos.model.ManifestType;
import uk.ac.standrews.cs.sos.model.Role;
import uk.ac.standrews.cs.sos.model.SignedManifest;
import uk.ac.standrews.cs.sos.utils.IO;

import java.io.IOException;

/**
 * Abstract class for all manifests that support signatures.
 *
 * @author Simone I. Conte "sic2@st-andrews.ac.uk"
 */
public abstract class AbstractSignedManifest extends BasicManifest implements SignedManifest {

    protected Role signer;
    protected IGUID signerRef; // FIXME - use when signer is not available
    protected String signature;

    /**
     * Constructor for a signed manifest.
     *
     * @param signer for this manifest
     * @param manifestType the type of manifest
     */
    protected AbstractSignedManifest(ManifestType manifestType, Role signer) {
        super(manifestType);

        this.signer = signer;
        if (signer != null) {
            this.signerRef = signer.guid();
        } else {
            this.signerRef = new InvalidID();
        }
    }

    protected AbstractSignedManifest(ManifestType manifestType, IGUID signerRef) {
        super(manifestType);

        this.signerRef = signerRef;
    }

    /**
     * Get the signer identifier used for this manifest
     *
     * @return the GUID for the signer
     */
    public IGUID getSigner() {

        return signerRef;
    }

    /**
     * Gets the signature of this manifest.
     *
     * @return signature of this manifest.
     */
    public String getSignature() {
        return this.signature;
    }

    /**
     * Verify this manifest against the given identity
     *
     * @param role used to satisfied the signature
     * @return true if the signature was generated by that role
     * @throws SignatureException if the verification could not be carried out
     */
    @Override
    public boolean verifySignature(Role role) throws SignatureException {

        if (signature == null || signature.isEmpty()) return false;

        try {
            String manifestToSign = IO.InputStreamToString(contentToHash());
            return role.verify(manifestToSign, signature);
        } catch (IOException e) {
            throw new SignatureException(e);
        }
    }

    /**
     * Generate the signature for this manifest
     *
     * @return the signature for this manifest
     * @throws SignatureException if the manifest could not signed
     */
    protected String makeSignature() throws SignatureException {

        try {
            String manifestToSign = IO.InputStreamToString(contentToHash());
            return generateSignature(manifestToSign);

        } catch (IOException e) {
            throw new SignatureException(e);
        }

    }

     /**
     * Generates the signature for this manifest.
     *
     * @return signature of this manifest.
     */
     private String generateSignature(String toSign) throws SignatureException {

         if (!signerRef.isInvalid()) {
             return signer.sign(toSign);
         } else {
             return "";
         }
     }

}
